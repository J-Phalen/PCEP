# Day 3 - PCAP Preparation Assignment
## Object-Oriented Programming, Strings & Advanced Python Features

**Estimated Time:** 180-240 minutes  
**PCAP Exam Coverage:** Sections 3, 4, 5 (74% of exam)  
**Environment:** VSCode with Python 3.x

---

## ðŸ“š Learning Objectives

By completing this assignment, you will master:
- String operations and methods (upper, lower, strip, split, join, etc.)
- Class definition with `__init__` and the `self` parameter
- Instance variables vs class variables
- Encapsulation using private attributes (name mangling)
- Single inheritance and method overriding
- Polymorphism and the `super()` function
- Special methods like `__str__()`
- List comprehensions with conditional logic
- Lambda functions with map(), filter(), and sorted()
- Generator functions using yield

---

## ðŸ“– Required Reading & Resources

### Essential Python Documentation:

1. **Strings:**
   - https://docs.python.org/3/library/stdtypes.html#string-methods
   - Focus on: upper(), lower(), strip(), split(), join(), replace(), find()

2. **Classes and OOP:**
   - https://docs.python.org/3/tutorial/classes.html
   - Study: class definition, __init__, self, inheritance, super()

3. **List Comprehensions:**
   - https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
   - Learn: basic syntax, conditional expressions, nested comprehensions

4. **Lambda Functions:**
   - https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions
   - Understand: anonymous functions, use with map/filter/sorted

5. **Generators:**
   - https://docs.python.org/3/tutorial/classes.html#generators
   - Learn: yield keyword, generator expressions, lazy evaluation

### Key PCAP Concepts to Master:

**String Immutability:**
- Strings cannot be changed after creation
- String methods return NEW strings
- Example: `s = "hello"; s.upper()` returns "HELLO" but `s` is still "hello"

**The self Parameter:**
- First parameter of instance methods
- References the current object
- Automatically passed when calling methods

**Name Mangling:**
- Double underscore prefix: `__attribute`
- Python mangles to `_ClassName__attribute`
- Provides "privacy" (not true encapsulation)

**Method Resolution Order (MRO):**
- Order Python searches for methods in inheritance
- Use `super()` to call parent class methods
- Single inheritance: Child â†’ Parent â†’ object

---

## ðŸŽ¯ Assignment Structure

Create a Python project:
```
day3_assignment/
â”œâ”€â”€ student_system.py    # Student and profile classes (Part 1-4)
â”œâ”€â”€ assistant_system.py  # Assistant class hierarchy (Part 5-6)
â”œâ”€â”€ data_analysis.py     # Comprehensions and lambdas (Part 7-8)
â”œâ”€â”€ main.py             # Complete learning platform (Part 9)
â””â”€â”€ session_log.txt     # Generated by your program
```

---

## Part 1: String Operations and Methods

**File:** `student_system.py`

### Task 1.1: Create string processing functions

**Function 1: `process_user_input(user_input)`**
- Strip whitespace using `.strip()`
- Convert to lowercase using `.lower()`
- Split into words using `.split()`
- Return tuple: (cleaned_string, word_list)

**Key String Methods:**
```python
s = "  Hello World  "
s.strip()      # "Hello World"
s.lower()      # "  hello world  "
s.upper()      # "  HELLO WORLD  "
s.split()      # ["Hello", "World"]
"-".join(["Hello", "World"])  # "Hello-World"
```

**Test Cases:**
```python
result = process_user_input("  HELLO WORLD  ")
# Should return: ("hello world", ["hello", "world"])
```

---

**Function 2: `validate_mood(mood)`**
- Valid moods: ['happy', 'neutral', 'stressed', 'tired', 'focused']
- Use `.lower()` and `.strip()` to normalize input
- Check if normalized mood is in valid list
- Return True or False

**Hint:** Use the `in` operator for membership testing

---

**Function 3: `format_name(name)`**
- Use `.title()` to capitalize each word
- Handle multiple spaces between words
- Return formatted name

**String Method Reference:**
- `.capitalize()` - First letter uppercase, rest lowercase
- `.title()` - First letter of each word uppercase
- `.casefold()` - Aggressive lowercase (for comparisons)

---

### Task 1.2: String slicing and indexing
Create `extract_initials(full_name)` function:
- Split name into words
- Extract first character of each word
- Join with dots
- Return uppercase initials

**Example:** "john doe smith" â†’ "J.D.S."

**String Indexing Review:**
```python
s = "Python"
s[0]      # 'P' (first character)
s[-1]     # 'n' (last character)
s[0:3]    # 'Pyt' (slice from 0 to 3, not including 3)
s[::2]    # 'Pto' (every second character)
```

---

## Part 2: Basic Class Definition

**File:** `student_system.py` (continue)

### Task 2.1: Create User class

**Requirements:**
```python
class User:
    """Represents a learning platform user"""
    
    def __init__(self, name, learning_style):
        """Initialize user with name and learning style
        
        Args:
            name (str): User's name
            learning_style (str): 'visual', 'auditory', or 'kinesthetic'
        """
        # Create instance variables
        # self.name = ?
        # self.learning_style = ?
        # self.sessions_completed = 0
    
    def increment_sessions(self):
        """Increment the sessions completed counter"""
        # Increase sessions_completed by 1
    
    def get_info(self):
        """Return formatted user information
        
        Returns:
            str: User info string
        """
        # Return string like: "User: Alice (visual) - 5 sessions"
```

**Key OOP Concepts:**

1. **The `__init__` Method (Constructor):**
   - Called automatically when object is created
   - Initializes instance variables
   - Must have `self` as first parameter

2. **Instance Variables:**
   - Belong to specific object instance
   - Created with `self.variable_name`
   - Different for each object

3. **Instance Methods:**
   - Functions defined inside class
   - Must have `self` as first parameter
   - Can access instance variables using `self`

**Usage Example:**
```python
user1 = User("Alice", "visual")  # __init__ called automatically
user1.increment_sessions()        # self = user1
print(user1.get_info())          # Outputs user information
```

---

### Task 2.2: Test your User class
Create multiple user objects and verify:
- Each user has independent sessions_completed
- Methods work correctly
- Info is formatted properly

---

## Part 3: Instance vs Class Variables

**File:** `student_system.py` (continue)

### Task 3.1: Create Session class with class variable

**Requirements:**
```python
class Session:
    """Represents a learning session"""
    
    # Class variable (shared by ALL instances)
    total_sessions = 0
    
    def __init__(self, user_name, mood, duration):
        """Initialize session and increment total count"""
        # Instance variables (unique to each instance)
        self.user_name = user_name
        self.mood = mood
        self.duration = duration
        
        # Increment class variable
        Session.total_sessions += 1
    
    @classmethod
    def get_total_sessions(cls):
        """Return total number of sessions created
        
        Returns:
            int: Total sessions across all users
        """
        return cls.total_sessions
    
    def get_session_info(self):
        """Return formatted session information"""
        # Return session details as string
```

**Critical Concept: Instance vs Class Variables**

| Aspect | Instance Variable | Class Variable |
|--------|------------------|----------------|
| Created in | `__init__` method | Class definition |
| Access | `self.variable` | `ClassName.variable` or `cls.variable` |
| Scope | Unique to each object | Shared by all objects |
| Example | `self.name` | `total_sessions` |

**The @classmethod Decorator:**
- Makes method work with class, not instance
- First parameter is `cls` (the class itself), not `self`
- Can access class variables but not instance variables
- Called with: `ClassName.method()` or `instance.method()`

**Test Example:**
```python
session1 = Session("Alice", "focused", 30)
session2 = Session("Bob", "tired", 20)
print(Session.get_total_sessions())  # Should print: 2
print(session1.get_total_sessions()) # Also works, prints: 2
```

---

## Part 4: Encapsulation and Private Attributes

**File:** `student_system.py` (continue)

### Task 4.1: Create StudentProfile class

**Requirements:**
```python
class StudentProfile:
    """Student profile with protected attributes"""
    
    def __init__(self, name, energy_level, focus_score):
        """Initialize student profile
        
        Args:
            name (str): Student name
            energy_level (int): Energy level 0-100
            focus_score (int): Focus score 0-10
        """
        self.name = name
        # Private attributes (name mangling)
        self.__energy_level = self.__validate_energy(energy_level)
        self.__focus_score = self.__validate_focus(focus_score)
    
    def __validate_energy(self, value):
        """Private method to validate energy level
        
        Returns validated value or raises ValueError
        """
        # Check if 0 <= value <= 100
        # Raise ValueError if not valid
        # Return value if valid
    
    def __validate_focus(self, value):
        """Private method to validate focus score
        
        Returns validated value or raises ValueError
        """
        # Check if 0 <= value <= 10
    
    def get_energy_level(self):
        """Get current energy level"""
        return self.__energy_level
    
    def set_energy_level(self, value):
        """Set energy level with validation"""
        self.__energy_level = self.__validate_energy(value)
    
    def get_focus_score(self):
        """Get current focus score"""
        return self.__focus_score
    
    def set_focus_score(self, value):
        """Set focus score with validation"""
        self.__focus_score = self.__validate_focus(value)
    
    def can_study(self):
        """Determine if student is ready to study
        
        Returns:
            bool: True if energy >= 30 and focus >= 5
        """
        # Check both conditions and return result
```

**Name Mangling Explained:**

```python
class Example:
    def __init__(self):
        self.__private = 42      # Name mangled to _Example__private
        self._protected = 24     # Convention: "protected" but not mangled
        self.public = 12         # Fully public
```

**Why Use Private Attributes?**
1. Prevent direct modification from outside the class
2. Enforce validation when values change
3. Hide implementation details
4. Make code more maintainable

**Testing Name Mangling:**
```python
student = StudentProfile("Alice", 80, 9)
print(student.name)               # OK: public attribute
print(student.get_energy_level()) # OK: public getter method
# print(student.__energy_level)   # ERROR: AttributeError
print(student._StudentProfile__energy_level)  # Works but BAD practice!
```

---

## Part 5: Inheritance and Method Overriding

**File:** `assistant_system.py`

### Task 5.1: Create base Assistant class

**Requirements:**
```python
class Assistant:
    """Base class for all assistant types"""
    
    def __init__(self, name):
        """Initialize assistant with name"""
        self.name = name
    
    def greet(self):
        """Return generic greeting"""
        return f"Hello! I'm {self.name}, your assistant."
    
    def give_advice(self, context):
        """Return generic advice
        
        Args:
            context (dict): Context information
        
        Returns:
            str: Generic advice message
        """
        return "I'm here to help you!"
```

---

### Task 5.2: Create StudyAssistant subclass

**Requirements:**
```python
class StudyAssistant(Assistant):
    """Specialized assistant for studying"""
    
    def __init__(self, name, subject_specialty):
        """Initialize study assistant
        
        Args:
            name (str): Assistant name
            subject_specialty (str): Specialized subject
        """
        # Call parent __init__ using super()
        super().__init__(name)
        # Add subclass-specific attribute
        self.subject_specialty = subject_specialty
    
    def greet(self):
        """Override with study-specific greeting"""
        # Return study-focused greeting mentioning subject
    
    def give_advice(self, context):
        """Override with study-specific advice
        
        Args:
            context (dict): Must include 'energy', 'focus', 'hours_studied'
        
        Returns:
            str: Tailored study advice
        """
        # Provide advice based on context values
        # If energy < 30: suggest break
        # If focus < 5: suggest focus techniques
        # If hours_studied > 3: suggest break
        # Otherwise: encourage continued study
    
    def recommend_break(self, hours_studied):
        """Recommend if student should take a break
        
        Returns:
            bool: True if hours_studied >= 2
        """
        # Return boolean
```

**Inheritance Concepts:**

1. **Super() Function:**
   - Calls method from parent class
   - Common use: `super().__init__(...)` in child's `__init__`
   - Follows Method Resolution Order (MRO)

2. **Method Overriding:**
   - Child class defines method with same name as parent
   - Child's method is called instead of parent's
   - Can still call parent's method using `super()`

3. **The isinstance() Function:**
   ```python
   study_bot = StudyAssistant("StudyBot", "Python")
   isinstance(study_bot, StudyAssistant)  # True
   isinstance(study_bot, Assistant)       # True (inheritance)
   isinstance(study_bot, str)             # False
   ```

---

### Task 5.3: Create WellnessAssistant subclass

**Requirements:**
- Inherit from Assistant
- Override `greet()` and `give_advice()`
- Add method `suggest_activity(mood)` that suggests activities based on mood
- If mood is "stressed": suggest "meditation or deep breathing"
- If mood is "tired": suggest "take a short nap or walk outside"
- If mood is "happy": suggest "keep up the great work!"

---

## Part 6: Polymorphism and Special Methods

**File:** `assistant_system.py` (continue)

### Task 6.1: Add __str__ method to StudentProfile

**Requirement:** Add this method to your StudentProfile class:
```python
def __str__(self):
    """Return string representation of student profile
    
    Returns:
        str: Formatted profile information
    """
    return f"Student: {self.name} | Energy: {self.__energy_level} | Focus: {self.__focus_score}"
```

**Special Methods (Magic Methods):**
- Begin and end with double underscores
- Called automatically by Python in certain situations
- Common examples:
  - `__init__`: Called when object is created
  - `__str__`: Called by `str()` and `print()`
  - `__repr__`: Called by `repr()` for developer representation
  - `__len__`: Called by `len()`
  - `__eq__`: Called by `==` operator
  - `__lt__`: Called by `<` operator

---

### Task 6.2: Demonstrate polymorphism
Create function that works with any Assistant type:

```python
def run_assistant_session(assistant, context):
    """Run session with any type of assistant
    
    Args:
        assistant (Assistant): Any Assistant subclass instance
        context (dict): Context information
    
    Returns:
        str: Session summary
    """
    # Call greet() - works for any assistant type (polymorphism!)
    # Call give_advice() with context
    # Return formatted summary
```

**Polymorphism Explained:**
- Greek: "many forms"
- Same method name, different behavior in different classes
- `run_assistant_session()` works with StudyAssistant, WellnessAssistant, or any future Assistant subclass
- Don't need to check type - just call the method!

---

## Part 7: List Comprehensions

**File:** `data_analysis.py`

### Task 7.1: Basic list comprehensions

**Concept:**
```python
# Traditional loop:
squares = []
for x in range(10):
    squares.append(x**2)

# List comprehension (equivalent):
squares = [x**2 for x in range(10)]
```

**Create these functions:**

**Function 1: `filter_ready_students(students)`**
- Parameter: list of StudentProfile objects
- Use list comprehension to get names of students where `can_study()` is True
- Return: list of strings (student names)

**Syntax:** `[student.name for student in students if student.can_study()]`

---

**Function 2: `categorize_energy_levels(students)`**
- Parameter: list of StudentProfile objects
- Return list of tuples: `(name, category)`
- Categories: "high" (>70), "medium" (40-70), "low" (<40)
- Use conditional expression in comprehension

**Syntax with if-else in comprehension:**
```python
[(s.name, 'high' if s.get_energy_level() > 70 else 'medium' if s.get_energy_level() > 40 else 'low') 
 for s in students]
```

---

**Function 3: `get_study_recommendations(hours_list)`**
- Parameter: list of hours studied (floats)
- Return: list of tuples `(hours, recommendation)`
- Recommendation: "Take a break" if hours >= 2, else "Continue studying"

---

### Task 7.2: Nested list comprehension

**Function: `flatten_session_data(session_lists)`**
- Parameter: list of lists (each inner list = sessions for one day)
- Example: `[[30, 45], [60, 20, 40], [50]]`
- Flatten to single list: `[30, 45, 60, 20, 40, 50]`

**Nested Comprehension Syntax:**
```python
[duration for day in session_lists for duration in day]

# Equivalent to:
result = []
for day in session_lists:
    for duration in day:
        result.append(duration)
```

---

## Part 8: Lambda Functions

**File:** `data_analysis.py` (continue)

### Task 8.1: Lambda with filter()

**Lambda Syntax:**
```python
# Regular function:
def is_even(x):
    return x % 2 == 0

# Lambda equivalent (anonymous function):
is_even = lambda x: x % 2 == 0

# Common use with filter:
evens = list(filter(lambda x: x % 2 == 0, numbers))
```

**Create these functions:**

**Function 1: `get_high_energy_students(students)`**
- Use `filter()` with lambda to get students with energy > 60
- Return list of StudentProfile objects

**Syntax:** `list(filter(lambda s: s.get_energy_level() > 60, students))`

---

### Task 8.2: Lambda with map()

**Function 2: `calculate_study_scores(students)`**
- Use `map()` with lambda to calculate readiness score for each student
- Formula: `(energy/10 + focus) / 2`
- Return list of floats

**The map() Function:**
- Applies function to every item in iterable
- Returns map object (convert to list)
- Example: `list(map(lambda x: x*2, [1,2,3]))` â†’ `[2,4,6]`

---

### Task 8.3: Lambda with sorted()

**Function 3: `sort_students_by_readiness(students)`**
- Sort students by readiness score (energy + focus*10)
- Use sorted() with key parameter
- Return in descending order

**The sorted() Function:**
```python
# Sort by default (alphabetical for strings, numerical for numbers)
sorted([3, 1, 2])  # [1, 2, 3]

# Sort with custom key function
sorted(students, key=lambda s: s.name)  # Sort by name

# Reverse order
sorted(students, key=lambda s: s.get_energy_level(), reverse=True)
```

---

## Part 9: Generator Functions

**File:** `data_analysis.py` (continue)

### Task 9.1: Create generator with yield

**Function: `energy_tracker(initial_energy, sessions)`**
```python
def energy_tracker(initial_energy, sessions):
    """Track energy level across multiple sessions
    
    Args:
        initial_energy (int): Starting energy
        sessions (list): List of session durations
    
    Yields:
        tuple: (session_number, energy_after_session)
    """
    energy = initial_energy
    for i, duration in enumerate(sessions, 1):
        energy -= duration * 2  # Each session reduces energy
        yield (i, energy)
```

**Generator Concepts:**

1. **The yield Keyword:**
   - Returns value but remembers state
   - Function becomes a generator
   - Execution pauses at yield, resumes on next call

2. **Lazy Evaluation:**
   - Values generated on-demand
   - Memory efficient for large datasets
   - Can represent infinite sequences

3. **Using Generators:**
```python
# Iterate over generator
for session_num, energy in energy_tracker(100, [20, 25, 30]):
    print(f"Session {session_num}: Energy = {energy}")

# Convert to list (loads all values)
results = list(energy_tracker(100, [20, 25, 30]))
```

---

### Task 9.2: Generator expression

**Function: `get_focus_scores(students)`**
- Return generator expression (not list)
- Yields focus score for each student
- More memory-efficient than list comprehension

**Generator Expression Syntax:**
```python
# List comprehension (creates full list in memory):
scores_list = [s.get_focus_score() for s in students]

# Generator expression (lazy evaluation):
scores_gen = (s.get_focus_score() for s in students)

# Use in for loop or convert to list
for score in scores_gen:
    print(score)
```

---

## Part 10: Complete Integration

**File:** `main.py`

### Task 10.1: Create LearningPlatform class

**Requirements:**
```python
class LearningPlatform:
    """Main platform managing students and assistants"""
    
    def __init__(self, platform_name):
        """Initialize learning platform"""
        self.platform_name = platform_name
        self.students = []
        self.assistants = []
        self.session_log = []
    
    def register_student(self, student):
        """Register a new student"""
        # Add to students list
    
    def add_assistant(self, assistant):
        """Add an assistant to platform"""
        # Add to assistants list
    
    def start_session(self, student_name, assistant_type, context):
        """Start a learning session
        
        Args:
            student_name (str): Name of student
            assistant_type (str): 'study' or 'wellness'
            context (dict): Session context
        """
        # Find student by name (use filter or comprehension)
        # Find appropriate assistant by type (use isinstance)
        # Call assistant's give_advice with context
        # Log session with Session class
        # Append to session_log
    
    def get_ready_students(self):
        """Get students ready to study using list comprehension"""
        # Return list of names where can_study() is True
    
    def get_top_performers(self, n=3):
        """Get top N students by readiness using lambda and sorted"""
        # Calculate readiness: energy + focus*10
        # Sort and return top n
    
    def generate_report(self, filename):
        """Generate session report and save to file
        
        Uses:
        - String formatting
        - File I/O with context manager
        - String methods (join, format)
        """
        # Create formatted report
        # Include: platform name, total students, total sessions
        # List all students with their stats
        # Save to file
    
    def __str__(self):
        """String representation of platform"""
        # Return summary: name, # students, # assistants, # sessions
```

---

### Task 10.2: Create main() demonstration function

**Requirements:**
```python
def main():
    """Demonstrate complete learning platform"""
    # 1. Create platform
    platform = LearningPlatform("CodeAcademy Pro")
    
    # 2. Create and register students (use string processing for names)
    students = [
        StudentProfile("alice johnson", 80, 9),
        StudentProfile("bob SMITH", 45, 6),
        StudentProfile("  Charlie Brown  ", 90, 8)
    ]
    # Format names properly and register each
    
    # 3. Add assistants
    study_bot = StudyAssistant("StudyBot", "Python")
    wellness_bot = WellnessAssistant("WellBot")
    platform.add_assistant(study_bot)
    platform.add_assistant(wellness_bot)
    
    # 4. Run sessions
    platform.start_session("Alice Johnson", "study", 
                          {'energy': 80, 'focus': 9, 'hours_studied': 1})
    
    # 5. Use comprehensions to analyze data
    ready_students = platform.get_ready_students()
    print(f"Students ready to study: {', '.join(ready_students)}")
    
    # 6. Use lambdas to sort and filter
    top_students = platform.get_top_performers(2)
    
    # 7. Generate report file
    platform.generate_report("session_log.txt")
    
    # 8. Demonstrate polymorphism
    for assistant in [study_bot, wellness_bot]:
        print(assistant.greet())
```

---

## ðŸ§ª Testing Requirements

Create comprehensive tests in `test_all.py`:

```python
def test_string_operations():
    """Test all string processing functions"""
    assert process_user_input("  HELLO  ") == ("hello", ["hello"])
    assert validate_mood("Happy") == True
    assert format_name("john doe") == "John Doe"
    print("âœ“ String operations passed")

def test_class_basics():
    """Test User and Session classes"""
    user = User("Alice", "visual")
    user.increment_sessions()
    assert "Alice" in user.get_info()
    
    Session("Bob", "focused", 30)
    assert Session.get_total_sessions() > 0
    print("âœ“ Class basics passed")

def test_inheritance():
    """Test inheritance and polymorphism"""
    study = StudyAssistant("Bot", "Python")
    assert isinstance(study, Assistant)
    assert "Python" in study.greet()
    print("âœ“ Inheritance passed")

def test_comprehensions():
    """Test list comprehensions"""
    students = [StudentProfile("A", 80, 9), StudentProfile("B", 20, 4)]
    ready = filter_ready_students(students)
    assert len(ready) == 1
    print("âœ“ Comprehensions passed")

def test_lambdas():
    """Test lambda functions"""
    students = [StudentProfile("A", 80, 9), StudentProfile("B", 60, 7)]
    high_energy = get_high_energy_students(students)
    assert len(high_energy) == 2
    print("âœ“ Lambdas passed")

# Run all tests
if __name__ == "__main__":
    test_string_operations()
    test_class_basics()
    test_inheritance()
    test_comprehensions()
    test_lambdas()
    print("\nâœ“âœ“âœ“ All tests passed! âœ“âœ“âœ“")
```

---

## ðŸ“Š Grading Criteria

| Component | Points | Description |
|-----------|--------|-------------|
| String Operations (Part 1) | 10 | All string methods used correctly |
| Basic Classes (Part 2) | 10 | Proper class definition with __init__ and methods |
| Class vs Instance Variables (Part 3) | 10 | Correct use of class variables and @classmethod |
| Encapsulation (Part 4) | 15 | Private attributes with getters/setters |
| Inheritance (Part 5) | 15 | Proper inheritance with super() and overriding |
| Polymorphism & Special Methods (Part 6) | 10 | __str__ implementation and polymorphic functions |
| List Comprehensions (Part 7) | 10 | All comprehensions working correctly |
| Lambda Functions (Part 8) | 10 | Proper use with map/filter/sorted |
| Complete Integration (Part 9-10) | 15 | Full working platform with all features |
| Code Quality & Testing | 5 | PEP 8 style, docstrings, passing tests |
| **Total** | **100** | |

---

## ðŸ’¡ Common Mistakes to Avoid

1. **Forgetting self:**
   ```python
   # WRONG:
   def get_info():
       return name  # Error: name not defined
   
   # CORRECT:
   def get_info(self):
       return self.name
   ```

2. **Modifying strings in place:**
   ```python
   # WRONG:
   s = "hello"
   s.upper()  # s is still "hello"!
   
   # CORRECT:
   s = "hello"
   s = s.upper()  # Now s is "HELLO"
   ```

3. **Not calling super() in child __init__:**
   ```python
   # WRONG:
   class Child(Parent):
       def __init__(self, name):
           self.name = name  # Parent's __init__ not called!
   
   # CORRECT:
   class Child(Parent):
       def __init__(self, name):
           super().__init__(name)
   ```

4. **List comprehension vs generator expression:**
   ```python
   list_comp = [x*2 for x in range(1000)]  # Creates full list
   gen_expr = (x*2 for x in range(1000))   # Lazy evaluation
   ```

5. **Accessing private attributes directly:**
   ```python
   # WRONG (but works with mangled name):
   student._StudentProfile__energy_level = 150
   
   # CORRECT:
   student.set_energy_level(150)  # Uses validation
   ```

---

## ðŸŽ“ PCAP Exam Connection

This assignment covers:

**Section 3: Strings (18%)**
- String methods and operations
- String immutability
- Slicing and indexing
- String comparison

**Section 4: Object-Oriented Programming (34%)**
- Class definition and instantiation
- __init__ and self
- Instance vs class variables
- Encapsulation and private attributes
- Single inheritance
- super() function
- Method overriding
- Polymorphism
- Special methods (__str__, etc.)

**Section 5: List Comprehensions, Lambdas, Generators (part of 22%)**
- List comprehensions with conditionals
- Nested comprehensions
- Lambda functions
- map(), filter(), sorted()
- Generator functions with yield
- Generator expressions

**Total Coverage: 74% of PCAP exam**

---

## ðŸ“š Additional Study Resources

- **Real Python - OOP:** https://realpython.com/python3-object-oriented-programming/
- **Real Python - Comprehensions:** https://realpython.com/list-comprehension-python/
- **Real Python - Lambda Functions:** https://realpython.com/python-lambda/
- **Python OOP Tutorial:** https://www.programiz.com/python-programming/object-oriented-programming
- **String Methods Reference:** https://www.w3schools.com/python/python_ref_string.asp

---

## âœ… Submission Checklist

- [ ] All string operations work correctly and handle edge cases
- [ ] Classes have proper docstrings and follow PEP 8
- [ ] Inheritance hierarchy is implemented correctly
- [ ] Private attributes use name mangling
- [ ] List comprehensions are concise and readable
- [ ] Lambda functions are used appropriately (not overused)
- [ ] All test cases pass
- [ ] Complete LearningPlatform demonstrates all concepts
- [ ] Code is well-commented and organized
- [ ] session_log.txt is generated successfully

---

**Remember:** OOP is 34% of the PCAP exam - spend extra time understanding classes, inheritance, and encapsulation! The exam will test your understanding of WHEN and WHY to use these concepts, not just HOW.

**Good luck with your PCAP preparation!**
